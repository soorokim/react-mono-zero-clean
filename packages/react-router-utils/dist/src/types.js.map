{"version":3,"file":"types.js","sourceRoot":"","sources":["../../src/types.ts"],"names":[],"mappings":"","sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\r\nimport React from \"react\";\r\n\r\n/* mapRouter type */\r\n// 처음에 setting할 router값을 받기위한 타입(home.tsx, auth.tsx 에서 mapRouter의 인자로 children을 받기위한 타입)\r\nexport type IRouterChildren = { [key: string]: IRouter };\r\n\r\n// router config를 위한 기본타입\r\nexport type IRouter<P = string, C = IRouterChildren> = {\r\n  regexPath: P;\r\n  title: string;\r\n  component: (args?: any) => React.ReactElement;\r\n  children?: C;\r\n};\r\n\r\n// router adapter에서 추가되는 타입\r\nexport type IRouterAddedProperty = {\r\n  path: string;\r\n};\r\n\r\n// router adapter가 적용된 후의 children의 타입\r\ntype IRouterAdaptedChildren<C> = C extends IRouterChildren ? { [key in keyof C]: IMapRouterReturn<C[key]> } : never;\r\n\r\n// mapRouter함수가 리턴하는 타입\r\nexport type IMapRouterReturn<C extends IRouter<C[\"regexPath\"]>> = IRouter<\r\n  C[\"regexPath\"],\r\n  IRouterAdaptedChildren<C[\"children\"]>\r\n> &\r\n  IRouterAddedProperty;\r\n\r\n/* param type */\r\n/**\r\n * 구분자(D)를 통해 문자열분리\r\n * @example\r\n * // return \"\" | \"home\" | \":param1(a|b)\" | \":param2(c|d)?\"\r\n * PathSeparate<\"/home/:param1(a|b)/:param2(c|d)\", \"/\">\r\n */\r\ntype PathSeparate<P extends string, D extends string> = P extends `${infer L}${D}${infer R}`\r\n  ? [L, ...PathSeparate<R, D>]\r\n  : [P];\r\n\r\n/**\r\n * @example\r\n * // return \"param(a|b) | param2(c|d)?\"\r\n * ExtractParam<\"\" | \"home\" | \":param1(a|b)\" | \":param2(c|d)?\">\r\n */\r\ntype ExtractParam<T extends string> = T extends `:${infer P}` ? P : never;\r\n\r\ntype Param<N = string, V = unknown, R = boolean> = {\r\n  name: N;\r\n  value: V;\r\n  required: R;\r\n};\r\n\r\n/**\r\n * required(?) 의 유무에따라 param을 parsing\r\n * @example\r\n * // return {name:param, value: a | b, required:true} | {name:param2?, value: c | d, required:false}\r\n * ParseParam<\"param(a|b) | param2(c|d)?\">\r\n */\r\ntype ParseParam<K extends string> = K extends `${infer N}(${infer P})`\r\n  ? Param<N, PathSeparate<P, \"|\">[number], true>\r\n  : K extends `${infer N}(${infer P})?`\r\n  ? Param<N, PathSeparate<P, \"|\">[number], false>\r\n  : Param<K, string, true>;\r\n\r\ntype GetParseParams<P extends string> = ParseParam<ExtractParam<PathSeparate<P, \"/\">[number]>>;\r\n\r\ntype ExtractValueOfParam<O extends Param, K> = Extract<O, { name: K }>[\"value\"];\r\n\r\n/**\r\n * required(?) 값에따라 param value의 key값을 다르게 parsing\r\n * @example\r\n * // return {param1:a | b, param2?: c | d}\r\n * ParseParam<\"/home/:param1(a|b)/:param2(c|d)\">\r\n */\r\nexport type ParamsFromPath<P extends string, O extends Param = GetParseParams<P>> = {\r\n  [key in Extract<O, { required: true }>[\"name\"]]: ExtractValueOfParam<O, key>;\r\n} &\r\n  { [key in Extract<O, { required: false }>[\"name\"]]?: ExtractValueOfParam<O, key> };\r\n"]}